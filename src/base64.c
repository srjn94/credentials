#include "base64.h"
#include "utils.h"
#include <limits.h>
#include <regex.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static const char base64_alphabet[] =
  "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  "abcdefghijklmnopqrstuvwxyz"
  "0123456789"
  "+/"
;

static const char base64_map[] = {
  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
  'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
  'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
  'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
  'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
  'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
  'w', 'x', 'y', 'z', '0', '1', '2', '3',
  '4', '5', '6', '7', '8', '9', '+', '/'
};

static const char ascii_map[] = {
    '\377', '\377', '\377', '\377', '\377', '\377', '\377', '\377',
    '\377', '\377', '\377', '\377', '\377', '\377', '\377', '\377',
    '\377', '\377', '\377', '\377', '\377', '\377', '\377', '\377',
    '\377', '\377', '\377', '\377', '\377', '\377', '\377', '\377',
    '\377', '\377', '\377', '\377', '\377', '\377', '\377', '\377',
    '\377', '\377', '\377', '\076', '\377', '\377', '\377', '\077',
    '\064', '\065', '\066', '\067', '\070', '\071', '\072', '\073',
    '\074', '\075', '\377', '\377', '\377', '\000', '\377', '\377',
    '\377', '\000', '\001', '\002', '\003', '\004', '\005', '\006',
    '\007', '\010', '\011', '\012', '\013', '\014', '\015', '\016',
    '\017', '\020', '\021', '\022', '\023', '\024', '\025', '\026',
    '\027', '\030', '\031', '\377', '\377', '\377', '\377', '\377',
    '\377', '\032', '\033', '\034', '\035', '\036', '\037', '\040',
    '\041', '\042', '\043', '\044', '\045', '\046', '\047', '\050',
    '\051', '\052', '\053', '\054', '\055', '\056', '\057', '\060',
    '\061', '\062', '\063', '\377', '\377', '\377', '\377', '\377',
    '\377', '\377', '\377', '\377', '\377', '\377', '\377', '\377',
    '\377', '\377', '\377', '\377', '\377', '\377', '\377', '\377',
    '\377', '\377', '\377', '\377', '\377', '\377', '\377', '\377',
    '\377', '\377', '\377', '\377', '\377', '\377', '\377', '\377',
    '\377', '\377', '\377', '\377', '\377', '\377', '\377', '\377',
    '\377', '\377', '\377', '\377', '\377', '\377', '\377', '\377',
    '\377', '\377', '\377', '\377', '\377', '\377', '\377', '\377',
    '\377', '\377', '\377', '\377', '\377', '\377', '\377', '\377',
    '\377', '\377', '\377', '\377', '\377', '\377', '\377', '\377',
    '\377', '\377', '\377', '\377', '\377', '\377', '\377', '\377',
    '\377', '\377', '\377', '\377', '\377', '\377', '\377', '\377',
    '\377', '\377', '\377', '\377', '\377', '\377', '\377', '\377',
    '\377', '\377', '\377', '\377', '\377', '\377', '\377', '\377',
    '\377', '\377', '\377', '\377', '\377', '\377', '\377', '\377',
    '\377', '\377', '\377', '\377', '\377', '\377', '\377', '\377',
    '\377', '\377', '\377', '\377', '\377', '\377', '\377', '\377'
};

// this can be highly optimized - lots of precomputations
bool isbase64(const char *str) {
  return true;   
}

size_t base64_encode_size(size_t n) {
  return 4 * (1 + (n / 3));
}

size_t base64_decode_size(size_t n) {
  return (n / 4) * 3;
}

void base64_encode(char *output, const void *input, size_t n) {
  char *ip, *op;
  uint8_t inbuf, outbuf;
  size_t nbits;
  
  op = output;
  nbits = 0;

  for (ip = (char*) input; *ip != '\0'; ip++) {
    inbuf = *ip;
    do {
      outbuf |= (inbuf & 0x80) >> 7;
      if (nbits % 6 == 5) {
        *(op++) = base64_map[outbuf & 0x3f];
      }
      inbuf <<= 1;
      outbuf <<= 1;
    } while (++nbits % 8);
  }

  size_t bits_remaining = (6 - nbits % 6) % 6;
  if (bits_remaining) {
    *(op++) = base64_map[(outbuf << (bits_remaining - 1)) & 0x3f];
    while (bits_remaining) {
      *(op++) = '=';
      bits_remaining -= 2;
    }
  }
  
  *op = '\0';
}

// assumes input is a valid base64 string : otherwise, undefined behavior
void base64_decode(void *output, const char *input) {
  uint8_t *ip, *op;
  uint8_t inbuf, outbuf;
  size_t nbits;

  op = (uint8_t*) output;
  nbits = 0;

  for (ip = (uint8_t*) input; *ip != '\0' && *ip != '='; ip++) {
    inbuf = ascii_map[(size_t) *ip];
    do {
      outbuf |= (inbuf & 0x20) >> 5;
      if (nbits % 8 == 7) {
        *(op++) = outbuf;
      }
      inbuf <<= 1;
      outbuf <<= 1;
    } while (++nbits % 6);
  }
  
  *op = '\0';
}

